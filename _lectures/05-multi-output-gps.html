---
title: "Multi-output Gaussian Processes"
abstract: "<p>In this lecture we review multi-output Gaussian processes. Introducing them initially through a Kalman filter representation of a GP.</p>"
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_gpss/multi-output-gps.md
week: 0
session: 5
reveal: 05-multi-output-gps.slides.html
youtube: "MkkeBmEZ8LE"
edit_url: https://github.com/lawrennd/talks/edit/gh-pages/_gpss/multi-output-gps.md
layout: lecture
categories:
- notes
---



<!-- Do not edit this file locally. -->
<!---->
<!-- Do not edit this file locally. -->
<!-- Do not edit this file locally. -->
<!-- The last names to be defined. Should be defined entirely in terms of macros from above-->
<!--

-->
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install gpy</span></code></pre></div>
<h2 id="gpy-a-gaussian-process-framework-in-python">GPy: A Gaussian Process Framework in Python</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/gpy-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_software/includes/gpy-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>Gaussian processes are a flexible tool for non-parametric analysis with uncertainty. The GPy software was started in Sheffield to provide a easy to use interface to GPs. One which allowed the user to focus on the modelling rather than the mathematics.</p>
<div class="figure">
<div id="gpy-software-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="https://mlatcl.github.io/gpss/./slides/diagrams//gp/gpy.png" width="70%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="gpy-software-magnify" class="magnify" onclick="magnifyFigure(&#39;gpy-software&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="gpy-software-caption" class="caption-frame">
<p>Figure: GPy is a BSD licensed software code base for implementing Gaussian process models in Python. It is designed for teaching and modelling. We welcome contributions which can be made through the GitHub repository <a href="https://github.com/SheffieldML/GPy" class="uri">https://github.com/SheffieldML/GPy</a></p>
</div>
</div>
<p>GPy is a BSD licensed software code base for implementing Gaussian process models in python. This allows GPs to be combined with a wide variety of software libraries.</p>
<p>The software itself is available on <a href="https://github.com/SheffieldML/GPy">GitHub</a> and the team welcomes contributions.</p>
<p>The aim for GPy is to be a probabilistic-style programming language, i.e., you specify the model rather than the algorithm. As well as a large range of covariance functions the software allows for non-Gaussian likelihoods, multivariate outputs, dimensionality reduction and approximations for larger data sets.</p>
<p>The documentation for GPy can be found <a href="https://gpy.readthedocs.io/en/latest/">here</a>.</p>
<h2 id="simple-kalman-filter">Simple Kalman Filter</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/simple-kalman-filter.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/simple-kalman-filter.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<ul>
<li><p>We have state vector <span class="math inline">\(\mathbf{X}= \left[\mathbf{ x}_1  \dots \mathbf{ x}_q\right] \in \mathbb{R}^{T \times q}\)</span> and if each state evolves independently we have <span class="math display">\[      
\begin{align*}
  p(\mathbf{X}) &amp;= \prod_{i=1}^qp(\mathbf{ x}_{:, i}) \\
 p(\mathbf{ x}_{:, i}) &amp;= \mathcal{N}\left(\mathbf{ x}_{:, i}|\mathbf{0},\mathbf{K}\right).
\end{align*}
\]</span></p></li>
<li><p>We want to obtain outputs through: <span class="math display">\[
\mathbf{ y}_{i, :} = \mathbf{W}\mathbf{ x}_{i, :}
\]</span></p></li>
</ul>
<h2 id="stacking-and-kronecker-products">Stacking and Kronecker Products</h2>
<ul>
<li>Represent with a ‘stacked’ system: <span class="math display">\[
p(\mathbf{ x}) = \mathcal{N}\left(\mathbf{ x}|\mathbf{0},\mathbf{I}\otimes \mathbf{K}\right)
\]</span> where the stacking is placing each column of <span class="math inline">\(\mathbf{X}\)</span> one on top of another as <span class="math display">\[
\mathbf{ x}= \begin{bmatrix}
      \mathbf{ x}_{:, 1}\\
      \mathbf{ x}_{:, 2}\\
      \vdots\\
      \mathbf{ x}_{:, q}
    \end{bmatrix}
\]</span></li>
</ul>
<h2 id="kronecker-product">Kronecker Product</h2>
<div class="figure">
<div id="kronecker-illustrate-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_illustrate.svg" width="80%" style=" ">
</object>
</div>
<div id="kronecker-illustrate-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-illustrate&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-illustrate-caption" class="caption-frame">
<p>Figure: Illustration of the Kronecker product.</p>
</div>
</div>
<div class="figure">
<div id="kronecker-ik-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_IK.svg" width="80%" style=" ">
</object>
</div>
<div id="kronecker-ik-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-ik&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-ik-caption" class="caption-frame">
<p>Figure: Kronecker product between two matrices.</p>
</div>
</div>
<h2 id="stacking-and-kronecker-products-1">Stacking and Kronecker Products</h2>
<ul>
<li>Represent with a ‘stacked’ system: <span class="math display">\[p
(\mathbf{ x}) = \mathcal{N}\left(\mathbf{ x}|\mathbf{0},\mathbf{I}\otimes \mathbf{K}\right)
\]</span> where the stacking is placing each column of <span class="math inline">\(\mathbf{X}\)</span> one on top of another as <span class="math display">\[
\mathbf{ x}= \begin{bmatrix}
      \mathbf{ x}_{:, 1}\\
      \mathbf{ x}_{:, 2}\\
      \vdots\\
      \mathbf{ x}_{:, q}
    \end{bmatrix}
    \]</span></li>
</ul>
<h2 id="column-stacking">Column Stacking</h2>
<p>For this stacking the marginal distribution over <em>time</em> is given by the block diagonals.</p>
<div class="figure">
<div id="kronecker-ik-highlighted-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_IK_highlighted005.svg" width="60%" style=" ">
</object>
</div>
<div id="kronecker-ik-highlighted-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-ik-highlighted&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-ik-highlighted-caption" class="caption-frame">
<p>Figure: The marginal distribution for the first three variables (highlighted) is givne by <span class="math inline">\(\mathbf{K}\)</span> when the form of stacking is <span class="math inline">\(\mathbf{I}\otimes \mathbf{K}\)</span>. This is the ‘column stacking’ case.</p>
</div>
</div>
<h2 id="two-ways-of-stacking">Two Ways of Stacking</h2>
<p>Can also stack each row of <span class="math inline">\(\mathbf{X}\)</span> to form column vector: <span class="math display">\[\mathbf{ x}= \begin{bmatrix}
      \mathbf{ x}_{1, :}\\
      \mathbf{ x}_{2, :}\\
      \vdots\\
      \mathbf{ x}_{T, :}
    \end{bmatrix}\]</span> <span class="math display">\[p(\mathbf{ x}) = \mathcal{N}\left(\mathbf{ x}|\mathbf{0},\mathbf{K}\otimes \mathbf{I}\right)\]</span></p>
<h2 id="row-stacking">Row Stacking</h2>
<p>For this stacking the marginal distribution over the latent <em>dimensions</em> is given by the block diagonals.</p>
<div class="figure">
<div id="kronecker-ki-highlighted-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_KI_highlighted002.svg" width="60%" style=" ">
</object>
</div>
<div id="kronecker-ki-highlighted-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-ki-highlighted&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-ki-highlighted-caption" class="caption-frame">
<p>Figure: The marginal distribution for the first three variables (highlighted) is independent when the form of stacking is <span class="math inline">\(\mathbf{K}\otimes \mathbf{I}\)</span>. This is the ‘row stacking’ case.</p>
</div>
</div>
<h2 id="mapping-from-latent-process-to-observed">Mapping from Latent Process to Observed</h2>
<div class="figure">
<div id="kronecker-ki-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_KI.svg" width="60%" style=" ">
</object>
</div>
<div id="kronecker-ki-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-ki&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-ki-caption" class="caption-frame">
<p>Figure: Mapping from latent process to observed</p>
</div>
</div>
<h2 id="observed-process">Observed Process</h2>
<p>The observations are related to the latent points by a linear mapping matrix, <span class="math display">\[
\mathbf{ y}_{i, :} = \mathbf{W}\mathbf{ x}_{i, :} + \boldsymbol{ \epsilon}_{i, :}
\]</span> <span class="math display">\[
\boldsymbol{ \epsilon}\sim \mathcal{N}\left(\mathbf{0},\sigma^2\mathbf{I}\right)
\]</span></p>
<div class="figure">
<div id="kronecker-wx-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//kern/kronecker_WX.svg" width="60%" style=" ">
</object>
</div>
<div id="kronecker-wx-magnify" class="magnify" onclick="magnifyFigure(&#39;kronecker-wx&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="kronecker-wx-caption" class="caption-frame">
<p>Figure:</p>
</div>
</div>
<h2 id="output-covariance">Output Covariance</h2>
<p>This leads to a covariance of the form <span class="math display">\[
(\mathbf{I}\otimes \mathbf{W}) (\mathbf{K}\otimes \mathbf{I}) (\mathbf{I}\otimes \mathbf{W}^\top) + \mathbf{I}\sigma^2
\]</span> Using <span class="math inline">\((\mathbf{A}\otimes\mathbf{B}) (\mathbf{C}\otimes\mathbf{D}) = \mathbf{A}\mathbf{C} \otimes \mathbf{B}\mathbf{D}\)</span> This leads to <span class="math display">\[
\mathbf{K}\otimes {\mathbf{W}}{\mathbf{W}}^\top + \mathbf{I}\sigma^2
\]</span> or <span class="math display">\[
\mathbf{ y}\sim \mathcal{N}\left(\mathbf{0},\mathbf{W}\mathbf{W}^\top \otimes \mathbf{K}+ \mathbf{I}\sigma^2\right)
\]</span></p>
<h2 id="kernels-for-vector-valued-outputs-a-review">Kernels for Vector Valued Outputs: A Review</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/multi-output-kernels.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/multi-output-kernels.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<h2 id="kronecker-structure-gps">Kronecker Structure GPs</h2>
<ul>
<li><p>This Kronecker structure leads to several published models. <span class="math display">\[
(\mathbf{K}(\mathbf{ x},\mathbf{ x}^\prime))_{i,i^\prime}=k(\mathbf{ x},\mathbf{ x}^\prime)k_T(i,i^\prime),
\]</span> where <span class="math inline">\(k\)</span> has <span class="math inline">\(\mathbf{ x}\)</span> and <span class="math inline">\(k_T\)</span> has <span class="math inline">\(n\)</span> as inputs.</p></li>
<li><p>Can think of multiple output covariance functions as covariances with augmented input.</p></li>
<li><p>Alongside <span class="math inline">\(\mathbf{ x}\)</span> we also input the <span class="math inline">\(i\)</span> associated with the <em>output</em> of interest.</p></li>
</ul>
<h2 id="separable-covariance-functions">Separable Covariance Functions</h2>
<ul>
<li><p>Taking <span class="math inline">\(\mathbf{B}= {\mathbf{W}}{\mathbf{W}}^\top\)</span> we have a matrix expression across outputs. <span class="math display">\[\mathbf{K}(\mathbf{ x},\mathbf{ x}^\prime)=k(\mathbf{ x},\mathbf{ x}^\prime)\mathbf{B},\]</span> where <span class="math inline">\(\mathbf{B}\)</span> is a <span class="math inline">\(p\times p\)</span> symmetric and positive semi-definite matrix.</p></li>
<li><p><span class="math inline">\(\mathbf{B}\)</span> is called the <em>coregionalization</em> matrix.</p></li>
<li><p>We call this class of covariance functions <em>separable</em> due to their product structure.</p></li>
</ul>
<h2 id="sum-of-separable-covariance-functions">Sum of Separable Covariance Functions</h2>
<ul>
<li><p>In the same spirit a more general class of kernels is given by <span class="math display">\[\mathbf{K}(\mathbf{ x},\mathbf{ x}^\prime)=\sum_{j=1}^qk_{j}(\mathbf{ x},\mathbf{ x}^\prime)\mathbf{B}_{j}.\]</span></p></li>
<li><p>This can also be written as <span class="math display">\[\mathbf{K}(\mathbf{X}, \mathbf{X}) = \sum_{j=1}^q\mathbf{B}_{j}\otimes k_{j}(\mathbf{X}, \mathbf{X}),\]</span></p></li>
<li><p>This is like several Kalman filter-type models added together, but each one with a different set of latent functions.</p></li>
<li><p>We call this class of kernels sum of separable kernels (SoS kernels).</p></li>
</ul>
<h2 id="geostatistics">Geostatistics</h2>
<ul>
<li><p>Use of GPs in Geostatistics is called kriging.</p></li>
<li><p>These multi-output GPs pioneered in geostatistics: prediction over vector-valued output data is known as <em>cokriging</em>.</p></li>
<li><p>The model in geostatistics is known as the <em>linear model of coregionalization</em> (LMC, <span class="citation" data-cites="Journel:miningBook78">Journel and Huijbregts (1978)</span> <span class="citation" data-cites="Goovaerts:book97">Goovaerts (1997)</span>).</p></li>
<li><p>Most machine learning multitask models can be placed in the context of the LMC model.</p></li>
</ul>
<h2 id="weighted-sum-of-latent-functions">Weighted sum of Latent Functions</h2>
<ul>
<li><p>In the linear model of coregionalization (LMC) outputs are expressed as linear combinations of independent random functions.</p></li>
<li><p>In the LMC, each component <span class="math inline">\(f_i\)</span> is expressed as a linear sum <span class="math display">\[f_i(\mathbf{ x}) = \sum_{j=1}^q{w}_{i,{j}}{u}_{j}(\mathbf{ x}).\]</span> where the latent functions are independent and have covariance functions <span class="math inline">\(k_{j}(\mathbf{ x},\mathbf{ x}^\prime)\)</span>.</p></li>
<li><p>The processes <span class="math inline">\(\{f_j(\mathbf{ x})\}_{j=1}^q\)</span> are independent for <span class="math inline">\(q\neq {j}^\prime\)</span>.</p></li>
</ul>
<h2 id="kalman-filter-special-case">Kalman Filter Special Case</h2>
<ul>
<li><p>The Kalman filter is an example of the LMC where <span class="math inline">\({u}_i(\mathbf{ x}) \rightarrow {x}_i(t)\)</span>.</p></li>
<li><p>I.e. we’ve moved form time input to a more general input space.</p></li>
<li><p>In matrix notation:</p>
<ol type="1">
<li>Kalman filter <span class="math display">\[\mathbf{F}= {\mathbf{W}}\mathbf{X}\]</span></li>
<li>LMC <span class="math display">\[\mathbf{F}= {\mathbf{W}}{\mathbf{U}}\]</span> where the rows of these matrices <span class="math inline">\({\mathbf{F}}\)</span>, <span class="math inline">\(\mathbf{X}\)</span>, <span class="math inline">\({\mathbf{U}}\)</span> each contain <span class="math inline">\(q\)</span> samples from their corresponding functions at a different time (Kalman filter) or spatial location (LMC).</li>
</ol></li>
</ul>
<h2 id="intrinsic-coregionalization-model">Intrinsic Coregionalization Model</h2>
<ul>
<li><p>If one covariance used for latent functions (like in Kalman filter).</p></li>
<li><p>This is called the intrinsic coregionalization model (ICM, <span class="citation" data-cites="Goovaerts:book97">Goovaerts (1997)</span>).</p></li>
<li><p>The kernel matrix corresponding to a dataset <span class="math inline">\(\mathbf{X}\)</span> takes the form <span class="math display">\[
\mathbf{K}(\mathbf{X}, \mathbf{X}) =  \mathbf{B}\otimes k(\mathbf{X}, \mathbf{X}).
\]</span></p></li>
</ul>
<h2 id="autokrigeability">Autokrigeability</h2>
<ul>
<li><p>If outputs are noise-free, maximum likelihood is equivalent to independent fits of <span class="math inline">\(\mathbf{B}\)</span> and <span class="math inline">\(k(\mathbf{ x}, \mathbf{ x}^\prime)\)</span> <span class="citation" data-cites="Helterbrand:universalCR94">(Helterbrand and Cressie, 1994)</span>.</p></li>
<li><p>In geostatistics this is known as autokrigeability <span class="citation" data-cites="Wackernagel:multivariate03">(Wackernagel, 2003)</span>.</p></li>
<li><p>In multitask learning its the cancellation of intertask transfer <span class="citation" data-cites="Bonilla:multi07">(Bonilla et al., n.d.)</span>.</p></li>
</ul>
<h2 id="intrinsic-coregionalization-model-1">Intrinsic Coregionalization Model</h2>
<p><span class="math display">\[
\mathbf{K}(\mathbf{X}, \mathbf{X}) =  \mathbf{ w}\mathbf{ w}^\top  \otimes k(\mathbf{X}, \mathbf{X}).
\]</span></p>
<p><span class="math display">\[
\mathbf{ w}= \begin{bmatrix} 1 \\ 5\end{bmatrix}
\]</span> <span class="math display">\[
\mathbf{B}= \begin{bmatrix} 1 &amp; 5\\ 5&amp;25\end{bmatrix}
\]</span></p>
<!--![image](../../../multigp/tex/diagrams/icmCovarianceImage)![image](../../../multigp/tex/diagrams/icmCovarianceSample1)![image](../../../multigp/tex/diagrams/icmCovarianceSample2)![image](../../../multigp/tex/diagrams/icmCovarianceSample3)![image](../../../multigp/tex/diagrams/icmCovarianceSample4)-->
<h2 id="intrinsic-coregionalization-model-covariance">Intrinsic Coregionalization Model Covariance</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/icm-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/icm-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai <span class="im">import</span> icm_cov</span></code></pre></div>
<center>
<span class="math display">\[k(i, j, \mathbf{ x}, \mathbf{ x}^\prime) = b_{i,j} k(\mathbf{ x}, \mathbf{ x}^\prime)\]</span>
</center>
<div class="figure">
<div id="icm-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class data="../slides/diagrams/kern/icm_covariance.svg" width="100%" style=" ">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/icm_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="icm-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;icm-covariance-plot&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="icm-covariance-plot-caption" class="caption-frame">
<p>Figure: Intrinsic coregionalization model covariance function.</p>
</div>
</div>
<h2 id="intrinsic-coregionalization-model-2">Intrinsic Coregionalization Model</h2>
<p><span class="math display">\[
\mathbf{K}(\mathbf{X}, \mathbf{X}) =  \mathbf{B}\otimes k(\mathbf{X}, \mathbf{X}).
\]</span></p>
<p><span class="math display">\[
\mathbf{B}= \begin{bmatrix} 1 &amp; 0.5\\ 0.5&amp; 1.5\end{bmatrix}
\]</span></p>
<!--![image](../../../multigp/tex/diagrams/icm2CovarianceImage)![image](../../../multigp/tex/diagrams/icm2CovarianceSample1)![image](../../../multigp/tex/diagrams/icm2CovarianceSample2)![image](../../../multigp/tex/diagrams/icm2CovarianceSample3)![image](../../../multigp/tex/diagrams/icm2CovarianceSample4)-->
<h2 id="lmc-samples">LMC Samples</h2>
<p><span class="math display">\[\mathbf{K}(\mathbf{X}, \mathbf{X}) = \mathbf{B}_1 \otimes k_1(\mathbf{X}, \mathbf{X}) + \mathbf{B}_2 \otimes k_2(\mathbf{X}, \mathbf{X})\]</span></p>
<p><span class="math display">\[\mathbf{B}_1 = \begin{bmatrix} 1.4 &amp; 0.5\\ 0.5&amp; 1.2\end{bmatrix}\]</span> <span class="math display">\[{\ell}_1 = 1\]</span> <span class="math display">\[\mathbf{B}_2 = \begin{bmatrix} 1 &amp; 0.5\\ 0.5&amp; 1.3\end{bmatrix}\]</span> <span class="math display">\[{\ell}_2 = 0.2\]</span></p>
<!--![image](../../../multigp/tex/diagrams/lmc2CovarianceImage)![image](../../../multigp/tex/diagrams/lmc2CovarianceSample1)![image](../../../multigp/tex/diagrams/lmc2CovarianceSample2)![image](../../../multigp/tex/diagrams/lmc2CovarianceSample3)![image](../../../multigp/tex/diagrams/lmc2CovarianceSample4)-->
<h2 id="lmc-in-machine-learning-and-statistics">LMC in Machine Learning and Statistics</h2>
<ul>
<li><p>Used in machine learning for GPs for multivariate regression and in statistics for computer emulation of expensive multivariate computer codes.</p></li>
<li><p>Imposes the correlation of the outputs explicitly through the set of coregionalization matrices.</p></li>
<li><p>Setting <span class="math inline">\(\mathbf{B}= \mathbf{I}_p\)</span> assumes outputs are conditionally independent given the parameters <span class="math inline">\(\boldsymbol{ \theta}\)</span>. <span class="citation" data-cites="Minka:learningtolearn97 Lawrence:learning04 Kai:multitask05">(Lawrence and Platt, 2004; Minka and Picard, 1997; Yu et al., 2005)</span>.</p></li>
<li><p>More recent approaches for multiple output modeling are different versions of the linear model of coregionalization.</p></li>
</ul>
<h2 id="semiparametric-latent-factor-model">Semiparametric Latent Factor Model</h2>
<ul>
<li><p>Coregionalization matrices are rank 1 <span class="citation" data-cites="Teh:semiparametric05">Teh et al. (n.d.)</span>. rewrite equation as <span class="math display">\[\mathbf{K}(\mathbf{X}, \mathbf{X}) = \sum_{j=1}^q\mathbf{ w}_{:, {j}}\mathbf{ w}^{\top}_{:, {j}} \otimes k_{j}(\mathbf{X}, \mathbf{X}).\]</span></p></li>
<li><p>Like the Kalman filter, but each latent function has a <em>different</em> covariance.</p></li>
<li><p>Authors suggest using an exponentiated quadratic characteristic length-scale for each input dimension.</p></li>
</ul>
<h2 id="semi-parametric-latent-factor-covariance">Semi Parametric Latent Factor Covariance</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/slfm-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/slfm-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai</span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai <span class="im">import</span> icm_cov</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai</span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mlai <span class="im">import</span> slfm_cov</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai.plot <span class="im">as</span> plot</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlai</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>K, anim<span class="op">=</span>plot.animate_covariance_function(mlai.compute_kernel, </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                                         kernel<span class="op">=</span>slfm_cov, subkernel<span class="op">=</span>eq_cov,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                         W <span class="op">=</span> np.asarray([[<span class="dv">1</span>],[<span class="dv">5</span>]])</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</span></code></pre></div>
<h2 id="semiparametric-latent-factor-model-samples">Semiparametric Latent Factor Model Samples</h2>
<p><span class="math display">\[
\mathbf{K}(\mathbf{X}, \mathbf{X}) = \mathbf{ w}_{:, 1}\mathbf{ w}_{:, 1}^\top \otimes k_1(\mathbf{X}, \mathbf{X}) + \mathbf{ w}_{:, 2} \mathbf{ w}_{:, 2}^\top \otimes k_2(\mathbf{X}, \mathbf{X})
\]</span></p>
<p><span class="math display">\[
\mathbf{ w}_1 = \begin{bmatrix} 0.5 \\ 1\end{bmatrix}
\]</span> <span class="math display">\[
\mathbf{ w}_2 = \begin{bmatrix} 1 \\ 0.5\end{bmatrix}
\]</span></p>
<!--![image](../../../multigp/tex/diagrams/slfmCovarianceImage)![image](../../../multigp/tex/diagrams/slfmCovarianceSample1)![image](../../../multigp/tex/diagrams/slfmCovarianceSample2)![image](../../../multigp/tex/diagrams/slfmCovarianceSample3)![image](../../../multigp/tex/diagrams/slfmCovarianceSample4)-->
<h2 id="gaussian-processes-for-multi-task-multi-output-and-multi-class">Gaussian processes for Multi-task, Multi-output and Multi-class</h2>
<ul>
<li><p><span class="citation" data-cites="Bonilla:multi07">Bonilla et al. (n.d.)</span> suggest ICM for multitask learning.</p></li>
<li><p>Use a PPCA form for <span class="math inline">\(\mathbf{B}\)</span>: similar to our Kalman filter example.</p></li>
<li><p>Refer to the autokrigeability effect as the cancellation of inter-task transfer.</p></li>
<li><p>Also discuss the similarities between the multi-task GP and the ICM, and its relationship to the SLFM and the LMC.</p></li>
</ul>
<h2 id="multitask-classification">Multitask Classification</h2>
<ul>
<li><p>Mostly restricted to the case where the outputs are conditionally independent given the hyperparameters <span class="math inline">\(\boldsymbol{\phi}\)</span> <span class="citation" data-cites="Minka:learningtolearn97 Williams:multiclass98 Lawrence:learning04 Seeger:multiple04 Kai:multitask05 Rasmussen:book06">(Lawrence and Platt, 2004; Minka and Picard, 1997; Rasmussen and Williams, 2006; Seeger and Jordan, 2004; Williams and Barber, 1998; Yu et al., 2005)</span>.</p></li>
<li><p>Intrinsic coregionalization model has been used in the multiclass scenario. <span class="citation" data-cites="Skolidis:multiclass11">Skolidis and Sanguinetti (2011)</span> use the intrinsic coregionalization model for classification, by introducing a probit noise model as the likelihood.</p></li>
<li><p>Posterior distribution is no longer analytically tractable: approximate inference is required.</p></li>
</ul>
<h2 id="computer-emulation">Computer Emulation</h2>
<ul>
<li><p>A statistical model used as a surrogate for a computationally expensive computer model.</p></li>
<li><p><span class="citation" data-cites="Higdon:high08">Higdon et al. (2008)</span> use the linear model of coregionalization to model images representing the evolution of the implosion of steel cylinders.</p></li>
<li><p>In <span class="citation" data-cites="Conti:multi09">Conti and O’Hagan (2009)</span> use the ICM to model a vegetation model: called the Sheffield Dynamic Global Vegetation Model <span class="citation" data-cites="Woodward:vegetation98">Woodward et al. (1998)</span>.</p></li>
</ul>
<h2 id="modelling-multiple-outputs">Modelling Multiple Outputs</h2>
<h2 id="running-example">Running Example</h2>
<h2 id="olympic-sprint-data">Olympic Sprint Data</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_datasets/includes/olympic-sprint-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_datasets/includes/olympic-sprint-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<table>
<tr>
<td width="70%">
<ul>
<li>Gold medal times for Olympic Sprints for Men and Women</li>
<li>100m, 200m, 400m</li>
<li>In early years of olympics not all events run.</li>
</ul>
</td>
<td width="30%">
<div class="centered centered" style="">
<img class="" src="https://mlatcl.github.io/gpss/./slides/diagrams//ml/100m_final_start.jpg" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
<small>Image from Wikimedia Commons <a href="http://bit.ly/16kMKHQ" class="uri">http://bit.ly/16kMKHQ</a> by <a href="https://www.staff.ncl.ac.uk/d.j.wilkinson/">Darren Wilkinson</a></small>
</td>
</tr>
</table>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>pip install pods</span></code></pre></div>
<p>The first think we will look at is a multiple output model. Our aim is to jointly model all <em>sprinting</em> events from olympics since 1896. Data is provided by Rogers &amp; Girolami’s “First Course in Machine Learning.” Firstly, let’s load in the data.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pods</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pods.datasets.olympic_sprints()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[<span class="st">&#39;info&#39;</span>], data[<span class="st">&#39;details&#39;</span>])</span></code></pre></div>
<p>When using data sets it’s good practice to cite the originators of the data, you can get information about the source of the data from <code>data['citation']</code></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[<span class="st">&#39;citation&#39;</span>])</span></code></pre></div>
<p>The data consists of all the male and female sprinting data for 100m, 200m and 400m since 1896 (six outputs in total). The output information can be found from: <code>data['output_info']</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[<span class="st">&#39;output_info&#39;</span>])</span></code></pre></div>
<p>In <code>GPy</code> we deal with multiple output data in a particular way. We specify the output we are interested in for modelling as an additional <em>input</em>. So whilst for this data, normally, the only input would be the year of the event. We additionally have an input giving the index of the output we are modelling. This can be seen from examining <code>data['X']</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;First column of X contains the olympic years.&#39;</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[<span class="st">&#39;X&#39;</span>][:, <span class="dv">0</span>])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&#39;Second column of X contains the event index.&#39;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data[<span class="st">&#39;X&#39;</span>][:, <span class="dv">1</span>])</span></code></pre></div>
<p>Now let’s plot the data</p>
<div class="figure">
<div id="olympic-sprint-data-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//datasets/olympic-sprint-data.svg" width="80%" style=" ">
</object>
</div>
<div id="olympic-sprint-data-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-sprint-data&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-sprint-data-caption" class="caption-frame">
<p>Figure: Olympic sprint gold medal winning times from <span class="citation" data-cites="Rogers:book11">Rogers and Girolami (2011)</span>.</p>
</div>
</div>
<p>In the plot above red is women’s events, blue is men’s. Squares are 400 m, crosses 200m and circles 100m. Not all events were run in all years, for example the women’s 400 m only started in 1964.</p>
<h2 id="gaussian-process-fit">Gaussian Process Fit</h2>
<div style="text-align:right">
<span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/olympic-sprint-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/olympic-sprint-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span>
</div>
<p>We will perform a multi-output Gaussian process fit to the data, we’ll do this using the <a href="https://github.com/SheffieldML/GPy">GPy software</a>.</p>
<p>We will look at modelling the data using coregionalization approaches described in this morning’s lecture. We introduced these approaches through the Kronecker product. To indicate we want to construct a covariance function of this type in GPy we’ve overloaded the <code>**</code> operator. Stricly speaking this operator means to the power of (like <code>^</code> in MATLAB). But for covariance functions we’ve used it to indicate a tensor product. The linear models of coregionalization we introduced in the lecture were all based on combining a matrix with a standard covariance function. We can think of the matrix as a particular type of covariance function, whose elements are referenced using the event indices. I.e. <span class="math inline">\(k(0, 0)\)</span> references the first row and column of the coregionalization matrix. <span class="math inline">\(k(1, 0)\)</span> references the second row and first column of the coregionalization matrix. Under this set up, we want to build a covariance where the first column from the features (the years) is passed to a covariance function, and the second column from the features (the event number) is passed to the coregionalisation matrix. Let’s start by trying a intrinsic coregionalisation model (sometimes known as multitask Gaussian processes). Let’s start by checking the help for the <code>Coregionalize</code> covariance.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> GPy</span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>GPy.kern.Coregionalize?</span></code></pre></div>
<p>The coregionalize matrix, <span class="math inline">\(\mathbf{B}\)</span>, is itself is constructed from two other matrices, <span class="math inline">\(\mathbf{B} = \mathbf{W}\mathbf{W}^\top + \text{diag}(\boldsymbol{\kappa})\)</span>. This allows us to specify a low rank form for the coregionalization matrix. However, for our first example we want to specify that the matrix <span class="math inline">\(\mathbf{B}\)</span> is not constrained to have a low rank form.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>, lengthscale<span class="op">=</span><span class="dv">80</span>)<span class="op">**</span>GPy.kern.Coregionalize(<span class="dv">1</span>,output_dim<span class="op">=</span><span class="dv">6</span>, rank<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div>
<p>Note here that the rank we specify is that of the <span class="math inline">\(\mathbf{W}\mathbf{W}^\top\)</span> part. When this part is combined with the diagonal matrix from <span class="math inline">\(\mathbf{\kappa}\)</span> the matrix <span class="math inline">\(\mathbf{B}\)</span> is totally general. This covariance function can now be used in a standard Gaussian process regression model. Let’s build the model and optimize it.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPy.models.GPRegression(X, y, kern)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>model.optimize()</span></code></pre></div>
<p>We can plot the results using the ability to ‘fix inputs’ in the <code>model.plot()</code> function. We can specify that column 1 should be fixed to event number 2 by passing <code>fixed_inputs = [(1, 2)]</code> to the model. To plot the results for all events on the same figure we also specify <code>fignum=1</code> in the loop as below.</p>
<div class="figure">
<div id="olympic-sprint-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//gp/olympic-sprint-gp.svg" width style=" ">
</object>
</div>
<div id="olympic-sprint-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-sprint-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-sprint-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the Olympic Sprint data.</p>
</div>
</div>
<p>There is a lot we can do with this model. First of all, each of the races is a different length, so the series have a different mean. We can include another coregionalization term to deal with the mean. Below we do this and reduce the rank of the coregionalization matrix to 1.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>kern1 <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>, lengthscale<span class="op">=</span><span class="dv">80</span>)<span class="op">**</span>GPy.kern.Coregionalize(<span class="dv">1</span>, output_dim<span class="op">=</span><span class="dv">6</span>, rank<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>kern2 <span class="op">=</span> GPy.kern.Bias(<span class="dv">1</span>)<span class="op">**</span>GPy.kern.Coregionalize(<span class="dv">1</span>,output_dim<span class="op">=</span><span class="dv">6</span>, rank<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>kern <span class="op">=</span> kern1 <span class="op">+</span> kern2</span></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPy.models.GPRegression(X, y, kern)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>model.optimize()</span></code></pre></div>
<div class="figure">
<div id="olympic-sprint-lmc-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//gp/olympic-sprint-lmc-gp.svg" width style=" ">
</object>
</div>
<div id="olympic-sprint-lmc-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-sprint-lmc-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-sprint-lmc-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the Olympic Sprint data.</p>
</div>
</div>
<p>This is a simple form of the linear model of coregionalization. Note how confident the model is about what the women’s 400 m performance would have been. You might feel that the model is being over confident in this region. Perhaps we are forcing too much sharing of information between the sprints. We could return to the intrinsic coregionalization model and force the two base covariance functions to share the same coregionalization matrix.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>kern1 <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>, lengthscale<span class="op">=</span><span class="dv">80</span>) <span class="op">+</span> GPy.kern.Bias(<span class="dv">1</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>kern2 <span class="op">=</span> GPy.kern.Coregionalize(<span class="dv">1</span>, output_dim<span class="op">=</span><span class="dv">6</span>, rank<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>kern <span class="op">=</span> kern1<span class="op">**</span>kern2</span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> GPy.models.GPRegression(X, y, kern)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>model.optimize()</span></code></pre></div>
<div class="figure">
<div id="olympic-sprint-icm-gp-figure" class="figure-frame">
<object class="svgplot " data="https://mlatcl.github.io/gpss/./slides/diagrams//gp/olympic-sprint-icm-gp.svg" width style=" ">
</object>
</div>
<div id="olympic-sprint-icm-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-sprint-icm-gp&#39;)">
<img class="img-button" src="{{ '/assets/images/Magnify_Large.svg' | relative_url }}" style="width:1.5ex">
</div>
<div id="olympic-sprint-icm-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the Olympic Sprint data.</p>
</div>
</div>
<p>Predictions in the multioutput case can be very effected by our covariance function <em>design</em>. This reflects the themes we saw on the first day where the importance of covariance function choice was emphasized at design time.</p>
<h2 id="thanks">Thanks!</h2>
<p>For more information on these subjects and more you might want to check the following resources.</p>
<ul>
<li>twitter: <a href="https://twitter.com/lawrennd">@lawrennd</a></li>
<li>podcast: <a href="http://thetalkingmachines.com">The Talking Machines</a></li>
<li>newspaper: <a href="http://www.theguardian.com/profile/neil-lawrence">Guardian Profile Page</a></li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-Bonilla:multi07" class="csl-entry" role="doc-biblioentry">
Bonilla, E.V., Chai, K.M., Williams, C.K.I., n.d. Multi-task <span>G</span>aussian process prediction.
</div>
<div id="ref-Conti:multi09" class="csl-entry" role="doc-biblioentry">
Conti, S., O’Hagan, A., 2009. Bayesian emulation of complex multi-output and dynamic computer models. Journal of Statistical Planning and Inference 140, 640–651. <a href="https://doi.org/doi:10.1016/j.jspi.2009.08.006">https://doi.org/doi:10.1016/j.jspi.2009.08.006</a>
</div>
<div id="ref-Goovaerts:book97" class="csl-entry" role="doc-biblioentry">
Goovaerts, P., 1997. <span>G</span>eostatistics <span>F</span>or <span>N</span>atural <span>R</span>esources <span>E</span>valuation. Oxford University Press.
</div>
<div id="ref-Helterbrand:universalCR94" class="csl-entry" role="doc-biblioentry">
Helterbrand, J.D., Cressie, N.A.C., 1994. Universal cokriging under intrinsic coregionalization. Mathematical Geology 26, 205–226.
</div>
<div id="ref-Higdon:high08" class="csl-entry" role="doc-biblioentry">
Higdon, D.M., Gattiker, J., Williams, B., Rightley, M., 2008. Computer model calibration using high dimensional output. Journal of the American Statistical Association 103, 570–583.
</div>
<div id="ref-Journel:miningBook78" class="csl-entry" role="doc-biblioentry">
Journel, A.G., Huijbregts, C.J., 1978. Mining geostatistics. Academic Press, London.
</div>
<div id="ref-Lawrence:learning04" class="csl-entry" role="doc-biblioentry">
Lawrence, N.D., Platt, J.C., 2004. Learning to learn with the informative vector machine. pp. 512–519. <a href="https://doi.org/10.1145/1015330.1015382">https://doi.org/10.1145/1015330.1015382</a>
</div>
<div id="ref-Minka:learningtolearn97" class="csl-entry" role="doc-biblioentry">
Minka, T.P., Picard, R.W., 1997. Learning how to learn is learning with point sets.
</div>
<div id="ref-Rasmussen:book06" class="csl-entry" role="doc-biblioentry">
Rasmussen, C.E., Williams, C.K.I., 2006. Gaussian processes for machine learning. mit, Cambridge, MA.
</div>
<div id="ref-Rogers:book11" class="csl-entry" role="doc-biblioentry">
Rogers, S., Girolami, M., 2011. A first course in machine learning. CRC Press.
</div>
<div id="ref-Seeger:multiple04" class="csl-entry" role="doc-biblioentry">
Seeger, M., Jordan, M.I., 2004. Sparse <span>G</span>aussian <span>P</span>rocess classification with multiple classes (No. 661). Department of Statistics, University of California at Berkeley.
</div>
<div id="ref-Skolidis:multiclass11" class="csl-entry" role="doc-biblioentry">
Skolidis, G., Sanguinetti, G., 2011. Bayesian multitask classification with <span>G</span>aussian process priors. IEEE Transactions on Neural Networks 22, 2011–2021.
</div>
<div id="ref-Teh:semiparametric05" class="csl-entry" role="doc-biblioentry">
Teh, Y.W., Seeger, M., Jordan, M.I., n.d. Semiparametric latent factor models. pp. 333–340.
</div>
<div id="ref-Wackernagel:multivariate03" class="csl-entry" role="doc-biblioentry">
Wackernagel, H., 2003. Multivariate geostatistics: An introduction with applications, 3rd ed. springer.
</div>
<div id="ref-Williams:multiclass98" class="csl-entry" role="doc-biblioentry">
Williams, C.K.I., Barber, D., 1998. Bayesian <span>C</span>lassification with <span>G</span>aussian processes. IEEE Transactions on Pattern Analysis and Machine Intelligence 20, 1342–1351.
</div>
<div id="ref-Woodward:vegetation98" class="csl-entry" role="doc-biblioentry">
Woodward, I., Lomas, M.R., Betts, R.A., 1998. Vegetation-climate feedbacks in a greenhouse world. Philosophical Transactions: Biological Sciences 353, 29–39.
</div>
<div id="ref-Kai:multitask05" class="csl-entry" role="doc-biblioentry">
Yu, K., Tresp, V., Schwaighofer, A., 2005. Learning <span>G</span>aussian processes from multiple tasks, in: Proceedings of the 22nd International Conference on Machine Learning (ICML 2005). pp. 1012–1019.
</div>
</div>

